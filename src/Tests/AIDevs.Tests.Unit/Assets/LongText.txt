Okay, so here's the thing. We have different practices as we are here in this room. Basically, we could most likely learn from each other. I can learn from you, you can learn from me,and everyone can learn from everyone else. And when you get those all good practices that we use,things that works for us, we can have a lot of things. But if you take any single person, you will find out,most likely not a single one of usactually uses this kind of practicesjust because they are not evenly distributed. And so, here will be a talk about things that work for me. Now, the thing is that they work for me,but they don't have to work for youbecause it all depends on the context. So, for example, I do business applications,microservices, these days microservices,enterprise applications, web applications,all this kind of stuff. But I'm not doing any game dev. And if I were doing game dev,everything I'm gonna tell you todaycan be complete bullshit, right? So, take this with a grain of salt,and basically be very carefulwhen you apply somebody else's advice. So, what's the context? So, we can compare whether your context applies,whether my suggestions applybecause the context is maybe similar. So, basically I've been doing this for the last 20 years,developing applications, and designing them as well,because architecture implementation,so I'm coding architect. Eight years with microservices, the last eight years,and before that, 12 years with monolithic applications. And there's pretty much every kind of systemsin a lot of domains. After 20 years, you don't care about the domain anymore. There have been so many of themthat it's not relevant anymore. So, imagine this. To talk about good practices, we're gonna take an example. And we're gonna imagine that we are working in a company,and this is just a medium-sized, event-driven systemwith Kafka, Kubernetes, 10 development teams, public cloud,all the standard jazz that comes with up-to-date environment. And a very complex domain where we have many devices,IoT, perhaps a lot of different usersand different companies that we cooperate with,and we have to invoice them. And we have a system, or a microservice, actually,that is responsible for importing invoices. Very simple thing, right? Other companies have those invoices,they send it off to us. The problem is, there is a very specific protocol for that,and whoever come up with that protocolwas completely dead in the brainbecause there is no way to actually createa corrective invoice, something which is required by law,but who cares? The protocol does not apply to this. So, our architecture and the situation right nowlooks like this, with this single microservicefor a single team, okay? We have this invoice importer in the middle. There is another billing system,which is something off the shelf,let's say Microsoft Dynamics or something like that,or Subbrim, whatever that is. And then there is a bunch of Kafka topics. If you know Kafka, then these will be compacted topicsthat provide you with data, and some external services,external applications that we have to talk with,and they are not in our hands,they are in the hands of other teamswith other developers, and basically other companies. And now comes a new requirement,and that requirement sounds very simple. Because that protocol that we have does not provideany way of actually creating a corrective invoice,what happens in those systems is thatthose corrective invoices, they actually come by email,and there are people who have to enter them by hand,you know, to that billing system,which is just manual work, it's a waste of time,and basically when you go into a large number of invoices,there'll be also a large number of corrective invoices,so it cannot continue, right? So the idea is the product owner comes in and says,"Okay, I want to upload the Excel file"with those corrective invoices,"so I do not need to perform all the checks, validations,"and enter the data myself into the billing system," right? That's the user story. Cool. So what is the third thing you should do? Well, a practice that works for me very wellis to first never do what they tell you to do,so basically don't implement it yet. Instead, ask whether it's worth implementing. Maybe it's not worth implementing,because if I think about it, about 10% of my work time,that means two years, I've spent on building softwarethat never got used by any users on production, okay? And that's because somebody had an idea,and they were very convincing,but basically there were no users,for those are no use cases, it makes no sense, right? So what can we do? First of all, how many invoicesdo we actually have per month? This way, upload it this way, so corrective invoices. Because if you have three, then maybe, you know,working for this for a month by a few developers,it's a huge cost, and it makes no sense whatsoever, right? It's cheaper to actually throw some money at a studentat Politechnika Warszawska,and they'll do it for free, right, basically. So, and they can do it for hundreds of years,because they are so cheap. So it makes no sense, right? The other thing is, what about the different data variants? So basically what happens is that we have several30, 50 different companies that are sendingthose corrective invoices to us,and there is not a standard format for this. Which means that every time there is a new company,or they have, you know, a new person in that company,they're gonna send us these invoices in different format. Which means that if we do not haveany kind of a contract for that data, okay,then when we try to read that Excel file,we're gonna search through the Excel file, basically,and most of the time we're gonna fail. That means that the maintenance costof actually keeping this in production is huge. Every single month we are going to work on this,just because the Excel file changed, right? There is no contract. So that's a huge cost. Then, what is the time and costfor uploading them right now, right? So let's compare the salary of the peoplethat do this job right now to the salary of the developers,and do this kind of analysis I just did with, you know,a student from Politechnika Warszawska. And so, that's what we do. We do not implement it right away,we just try to find out whether it's worth implementing. So let's get some numbers. Right now, processing manually those invoicescost about 40,000 euros per month, right? Sounds like a lot. Well, so if we do implement this,then let's say we're gonna lower that numberto about 20,000 euros per month, not to zero completely,because, well, again, you have to receive thisthrough email, you have to upload this,basically you have to have a person clicking buttons,because you cannot automate it for a reason, okay? And so let's say we're gonna save about half of that,and there's gonna be a trust of the billing people increase,meaning that, you know, you're gonna have some friendsin this company, because you did something importantfor them, and maybe you have some political gains,because your product owner is basically playinga political game against other product owners,and you know, who's better at what,and what can they get out of it. But what are the cons? First of all, it costs 10,000 euros per monthof implementation, right? Just, you know, a single person working for thisactually costs a lot, and these are developers, right? The highest cost in the IT. Then the maintenance cost is going to be about,you know, 250 euro per month with the data variation,because you're gonna have to go back to it and fix it,right, or change it. And then there is another thing which is much more important,opportunity cost, meaning if I'm doing this,I'm not doing something else. Maybe I can find something much more importantfor the company to do, and to bring much more moneythan 20,000 euros per month, right? So this kind of analysis, I guarantee you thatit's gonna help you, your product owner might not like itat the very beginning, but when they find outthat due to that, they can actually skipand not do unimportant things, and instead providesome real benefit for the company,then they're gonna get raised,so they're gonna love you anyway. So that's one thing. Now, let's move forward. So we decided to actually implement this, right,for whatever reason. Then the product owner actually brings usthis kind of a mock-up of a UI. And they say, okay, I got a button with upload file,then I need to see some errors when I have them,and I need to see a list of all the old imports, right? And when I see those imports, I would like to downloadCSV files so that I can actually fix those things,and basically call another company and find outwhat's wrong with this file and what's wrong with thosenumbers, and basically have that solved,and then upload it again. So that's the idea. That's a mock-up, right? But the mock-up is actually not analysis,meaning that the first thing you should do is not, again,not implement anything, but actually createthat analysis, meaning, for example, behavioral scenarios. Here you have some behavioral scenarios,and we write them down with no details, just the title. So basically we are saying what we are going to do. Something like we're gonna convert each line of the invoiceinto an invoice in the billing, right? Of each line of the Excel file into the invoicein the billing, or that we should return a list of imports,but then we think about, you know,what are the coronary cases can we find out? What if the file is more than 100 megabytes? Do we have enough memory for this? Can we have an out-of-memory error in that case, right? All this kind of coronary cases. So you write them down, and then you have to designthe architecture, and when I say design the architecturefor such a simple thing like importing invoices,correct invoices, by a button, right? People are like, what do you mean by that? We have a microservice, let's put it there. That's it, right? A new feature, a new controller, rest controller,and then just process this, and that's pretty much it. Well, not exactly, because what happens is that,let's take a look at what the cognitive load,meaning the number of things you have to put into your headto be able to work with this microservice,what the number is right now. So right now, to work with this microservice,you have to understand how Kafka works,because it depends on Kafka heavily, right? You have to understand how to read models,how read models work, and how to read themfrom Kafka, with Kafka Streams,and how to send events to Kafka as well. Then you have to understand the business processof validating a partner, so basically another applicationthat you talk with. Then you have to understand the very strange protocolthat it has, and what are the invoices presented,so the DTOs, on both sides, right? On the billing system and on the external system. And the peculiar protocol has actually a bookthat you have to read to do it. What happens when we add that feature to that microservice? Then we have additional cognitive load,new things you have to understandwhen you start working with that microservice. So now you have to understand,and this is in Java, so basically,this will be references to the libraries in Java,how to upload a file, basically, in Spring MVC,which is something not very difficult,but normal developers, web developers, don't do that, okay? So then you have to think abouthow do I actually read an Excel file? And there is another library for this, and it's huge,and it has a huge documentation for this. And then you want to list of errors,and you want to return this error as a CSV file, right? So you have to understand how to build that. Most likely with some kind of a library,maybe you'll do it by hand because that's actually simple. And then you have to add a database,because that microservice doesn't have a database,and now we have to store the informationabout all the failed importing of those Excel files,which means that while it's not very difficult,we have to add the secrets to the databaseto some kind of a vault,then we have to add some kind of a migration library,like Flyway or Liquibase in the JVM world,and then we have to add those scripts that actually migrate,and so on and so on. So there is much more in terms of cognitive loadthe things that you have to understandto be able to work with this microservice, right? Okay, so what would happen if we were not aboutto add this feature to an existing microserviceinside an existing code,but instead we are going to create three moduleswithin that microservice. In that case, take a look at this. Now we have an xlsx updater,uploader, sorry, which will be a new modulethat will take over uploading the file from the web. We will have an existing module, invoice importer,and another one, which is called invoice reporter,to create those reports that were required from the web. Right? When you take this and you think aboutdifferent, about cognitive load that now you will haveworking with each of those modules,then remember, modules, you can work alonewithin the module, that's the whole concept. Basically, we want to have modulesbecause you can think about within the boxand not think about other modules in the application. And when you do this, then the invoice importer moduledoes not change, these are exactly the same cognitive load,the same features that we already had,but if we add another xlsx uploader module,then to work with this module, you have a much smaller subsetof actually things you have to understandand put it to your head to be able to work with it. When you go to the reporter module,that's the one that has got DB,so before you actually go there,you don't have to understand how you actually connectto the DB, okay, or what kind of a migration strategyyou have for the scripts and so on. So by just modularizing this, simple microservice, okay,and putting it into three modules within that microservice,it's much easier to work with each of those modulesbecause there is much less things to put into your head. And that also means there is a lower implementation risk. Now, if you want to read more about this,actually, the gentleman speaking before mementioned the book "Team Topologists",which actually describes this conceptof cognitive load and overload,and that's a very old idea, and it just says,if you have to have more things into your headwhen you're doing something, you're going to do it slower. That's the whole thing, right? If you don't have to think about itbecause there's not much, you're gonna do it faster. So we're gonna speed up just by modularizing our application. But that's not everything, because one of the jobsof an architect is actually to design for failure. So basically, design the system so that when it fails,it fails in a graceful manner. You expect the failure. You want to understand and to be able to behave in a wayso that it's not the end of the world, basically. So what it means in this perspective is,every time you design other new feature, basically,we have to think about what kind of risks do we have. And most of the time, it will be security. So like, you know the term DevOps,it's actually FinSecDevOps, meaning financial securitydevelopers operating their systems in production. So it's much more complex. So in a simplest manner, it means you design something,think about it, how does it impactthe security of the system, that's it. What can you do with this? Well, for example, you can do threat modeling. That's a very simple method of actually analyzingdoes it increase the, improve the securityor actually lowers the security, right? Things like analyzing what kind of vectorsof attack do you have. So if we do this for this single requirement,you will find out that because we are using,because we are working within an existing microservice,right now, our surface area for attackis actually going to increase a lot. Because first of all, we are adding HTTP endpoints,UI basically, right? We didn't have that before. Then, so you can attack this way. Then we are adding a large library called Apache Poijust to read those Excel files. Meaning you can have bugs there. And then you can do errors in parsing. And basically, we can attack you by providingstrange data within the Excel file, right? And then you have to think about memory leaks. What if those Excel files are pretty large, right? What if this is half a gigabyte of an Excel file, right? So just by adding that simple feature,you're making this a much larger problem, right? Is there another way to do it? How about we were about to create the same architecture,but this time it's not modules anymore. These are microservices, three different microservices. Now that's a lot of work, right? Not exactly, actually creating a new microservicetakes 4,5 seconds. If you have a good tailored template,and I'm including going to production. So that's what happens when you have a good system,good microservice-based system. But with this kind of approach,there is of course a cost of communicationwith microservices. But now what happens is that we do not increasethe attack area, surface area for that microservicewhich already exists. We add two new microservices. Each of them has much smaller attack area,so it's much easier to protect, okay? So that's what you should do. Think about whether you want to have another moduleand another microservice in such a case,because there are completely different requirements,non-functional requirements for the processthat we are talking here about,which is uploading a corrective invoice,and for the process of just normal workingwith those invoices for the current existing microservice. So for example, right now, if you think about it,the existing microservice has got an SLAor availability of 99, which isn't high,but again, it's 99, right? We want it to work most of the time. Then the RPSs are requests per second are pretty low,and frequency of change is also pretty low. However, if we add these Excel filesand processing of those Excel filesfor which the SLA or availability is zero,if it doesn't work today,you can upload the file tomorrow, right? There's like, if we have 20 days after the end of the monthto actually upload those files with corrective invoices. And request per second is, again, completely zero, right? But the frequency of change,what happens if we don't have a protocol for those filesso that every single time we have somebody uploads a file,it turns out that there is a new version,or the data is in a different, basically, order,or maybe in different cells. In that case, the frequency of change is going to be huge. And if you have a high SLA and a huge frequency of change,that's a very bad place to be,because you know who makes bugs? You know what happens,if you want to have a high SLA or availability,you cannot have a lot of bugs, right? Who makes bugs? Developers. When do they make bugs? When they make changes. So you want to have a lot of changes,you're gonna have a lot of bugs. Simple. Okay. So then another thing is,this feature, actually,because it works a few times a month,maybe it's not even worth to have it as a microservice. Maybe it could be like Lambda,or maybe it could be like a cron job of Kubernetesso that you can scale down to zero, basically,because you don't need to reserve that memorybecause it doesn't work most of the time, right? So there are a lot of different optionsthat you have to think about,and I urge you to think about non-functional requirementsfor the feature and compare themto other non-functional requirementsfor the features within the application you already have,because you can find out that it makes much more senseto actually put it as another applicationor a microservice in this case, okay? And then, after all of this, okay,there is another thing,which is do not try to implement the whole thing. Think about it,about what is the least amount of work I can doto get it to production,to find out whether it works, and it's useful. Do I really have users working on thisand have the feedback from the users? So even with such a simple story,that was a single user story, right? I'm gonna have MVPs,and let's take a look at those MVPs. I can actually basically split it into two different MVPs,one being having all those scenarios that are on the top,and another one,which is the returning list of importsand downloading the CSV file basically later on. You don't have to do everything at once, right? You can have the upper part deployed to production,get feedback from customers,or actually the business people who actually work on this,and then decide whether you want to implement the restor whether you want to move back. It's always a good idea from a business perspectivenot to implement the whole thing,but even if it's simple, split it into smaller thingsthat you can get to production, get to user,get the feedback back. So now that we have done all of this,it's time to finally refine those requirements,meaning write the whole analysis. So here we are writing down behavioral scenarios,and this is a testing library for the JVM called Spock,where we put all these things, like the behavioral scenarios,so all the interactions with the system,the user with the system and the system with other systems,and between different microservices as well,into these kind of stories. When we do this, and when you get it down,so basically we are writing test scenarios, right? When you have it down, then what happens is, first of all,you will find out a lot of interesting things. Like for example, just to design this,to be able to write those scenarios,you have to understand how the library works,and when you look at how the library works,you will find out that you don't have to loadthe whole Excel file into the memory,you can actually work on the file on disk,meaning memory leak is not likely,because you don't care whether this filehas got 100 megabytes or 500 megabytes, right? And so on and so on. So basically there's a lot of options there when you can,oh, it's gonna be much easier than what I thought, right? For example, or maybe the other way around. And then what happens is, again,we are not implementing anything,we just implemented the test, not even implemented the test,we would just describe those tests as behavioral scenarios,so basically given when then, all these kind of steps, right? Out of this file, test file which actuallydoes not run anything yet, what I get is this. This is reports from Spock reports,meaning this is a readable web pagefor the business people to verifywhether how we think it should work in different cases,especially coronary cases, it's exactly how it should work. So now I send this file to the business people to verify. So I'm not implementing something and learning later onthat they said, no, no, no, it cannot work this way, right? Simple. And so let's take a look. We haven't wrote a single line of a production code yet,but we have verified the validitywhether it makes sense to implement this. We have designed the architecture, designed for failure,analyzed the, done a little bit of a threat modeling there. We split this solution into different MVPsso that we can do something smaller and get feedback faster,refine the requirements as behavioral scenariosand basically send them to the business peopleto verify the requirements,whether we understand them correctly. And the best part is this is done in one hour, all of it. It may be, it might sound like a lot of things to dowhen you do it the first time, but when you are used to it,it takes one hour and you're done, right? And we have a lot of positive feedback from this. For example, I don't have to implement every single stupid ideathat my product owner has, which is great, okay? So now it's time to actually implement the codeand basically write this thing, right? And here is a problem because sometimes when you write,when you actually have this kind of a feature to write,it's very simple. Sometimes you just see the solution yourself, right? For example, I've spent a few yearson content management systems, on e-commerce and stuff like this,so basically I can see the code within my mind eyeswhen somebody tells me about the features for e-commerceor a content management system. It's that simple after a few years, right? But what happens when, so you can print this code,wake me up at the 3 a. m. , ask me for a featureand I'll print the code out like a printer, right? But what happens when their feature is not that simple? And here are two things that happen at this point,or might happen, okay? Sometimes the senior people are getting stuckwith thinking the same way that they always did. So basically I have one tool or a few tools, right? This is a new problem. I'm going to apply one of those tools whether it works or not. And they try to implement that featureand it's an ugly implementation. It's a very naive implementation of the featurejust because we are trying to use the same practices we did before. Now for junior people, there's another threat,which is I ask them, so somebody says on the planning session,for example, or on the daily, I'm going to take this,and this is the junior developer, right? And I'm asking, and the next day they basically on the dailyand say, yeah, I'm still working on this. And the next day they say, I'm still working on this. And so I ask them, do you need any help? Do you have any blockers? No, no, no, I'm still thinking about how to do it, right? And after a week, they say, I don't know how to do it. So you've wasted a week of time basically on doing what? Waiting for the idea to come up, how to solve this, right? No, it makes no sense. So basically what I would like to show youis something how to solve this kind of a problemwhen you don't know how to do that thing,how to solve the problem, right? And there are many solutions to this. First one is called baby steps to test development, right? Which is take this problem, get a subset of this problem,solve simple that it's naive, and then try to implement thisand implement a test on this, and then move forwardone step forward, right? Again, a very simple thing. So how would that work? It would be something like this. Here is the scenario that we want to implement. Should convert each line except header into inverse event. And that's a huge one that requiresthe whole thing to work, right? But we can split it into smaller ones. For example, here you have the first thing I want to dois I should pass upload results to the reporterfrom the first module or the microserviceto the second one, right? That's it. And if you think about it, the implementation is trivialbecause you don't have to parse anything. You just pass, whenever somebody calls you,you just pass something to another moduleor to another microservice. That's it, right? Okay, so what's the benefit of this? Well, we are moving forward. So let's do another thing. Okay, so now I would like to, when the file is uploaded,I would like to see the result. I would like the result to have a name for it, right? So baby step. Now I need to at least be able to read the file. So I'm learning how to read the name of the file. I'm not parsing the Excel file yet, right? Only the name of the file. And then you take another one. How about we see the result that contains the username? Oh, and now I have to learn how to get the usernamefrom this whole system basically, right? And one by one, you move forward. And the thing is, it doesn't sound like a complete,you know, implementation because sooner or later,you will have something like I need to have,I need to know how many Excel files,not how many invoices are in the Excel file. And you will have to read this file, right? But you are much closer than you were beforeto the proper solution. And basically now you have to only understandhow to count the number of roles in an Excel file,not read them actually, right? So you're moving by very small steps. And this is going to unblock youfrom spending five days on, I don't know, right? I'm experimenting, I'm learning things. I have a bunch of code that does something right now. So maybe it's easier actually to implement now error casesinstead of reading all this, implementing the, you know,reading the whole Excel file,then you can say what should happenwhen the file is not there and so on and so on. So very small baby steps, not to get you to the goal,but to unblock you and keep you moving basically. But sooner or later, you will have to read that file. And basically that's the end of the happy path. Now we have to actually learn the library and how to use it. But with those baby steps, you will have a bunch of code,you will have a much faster feedback. That's not the only option you have. How about doing something completely different,which is called backward programming. And what that is, is when you have to implement a method,let's say we have this large scenario with, you know,reading the whole file, understanding everything,importing invoices, all this kind of stuff, right? What we could start with is go into our methodand start from the end of that method,meaning what do I have to return, right? Now think about the next line. How do I get that data? Where do I get that data from? So for example, I need to return a result, right? How would I get that data? Well, if anything is basically,if we have anything to report as a successful import,then we would return a result. And I can implement that method saying,oh, I would like to have this result,I would like to have the method calledsuccessful import in there,that will tell me exactly if I have more than zero, right? Then you will say, okay, how do I create that result? Maybe I will have a method which will provide mewith a successfully imported,the number of those rows, or maybe all the rows,maybe failed rows, and maybe the username, and so on. So you're moving from the bottom up. You're not writing from the top down like usually,but from the bottom up, looking at what you needand where can you get that data from? And if you do this, you will find outthat quite often it's much easier to do,because I don't know how the whole method should look like,but I know what I need to return. And let's think about where do I get that from, right? So that's the backwards programming. From the back to the, from the bottom to the top, basically. Now, this will also keep you moving,learning about what you actually have to do, right? And not get you stuck,but that's not the only option you have. You can do this kind of a high-level design. Maybe you remember from the universityor the Politechnica Warszawska, for example,when you were designing, maybe you didn't,I don't know if it's still relevant,but basically back in my days,they would teach you how to write an algorithmwithout any actual language. So it's like a high-level abstract designof the thing that you're gonna do, right? And you can do the same thing with a real language. So for example, I can think about,oh, I think I should open the workbook,which is expressing the Excel file,then load a sheet because they got sheets, right? Then convert all the rows,then have some kind of a result object for all those rows,export them to another system,and basically you're writing the whole methodon the top level with no concernfor the actual implementation at the bottom. So you're not trying to go from the top, deep down,but just like a spread search for possible solution, right? When you do this, it's gonna create a lot of problemsbecause you are ignoring all the dirty details. This method, this library throws exceptionsthat you have to take care of. There are many things that can happen. There's actually all those small detailswhich make our work very fun, right? If it wasn't there,there are business people would be ableto write this code themselves. But that will also get you movingand thinking in terms of a solutioninstead of a blank paper, right? And there's another method, which is learning by chaos. So for example, here we can just try to read the fileand of course print Dupa somewhere there, right? Try to read some lines and print the Dupa there as wellbecause tradition requires that we print that, right? And basically play around and fuck around the fileand the whole importing mechanism, right? Just to see how it works, right? But it makes no sense. This is not craftsmanship. This is bad, ugly code. How can you do something like this and show it to us? Well, there's one trick, you know? The trick is never push this repository, okay? Just play around, fuck around. Nobody will know. It's okay, it's completely fine. Experienced senior developers do it all the time, right? You just never see the effects of that workbecause they don't push it into the repository. But if you pair programming with them,you will see they do that, okay? So there's a lot of way to do it. So which one is better when you are blocked, basically, right? And which method is the best here? And the interesting thing is neitherbecause it's not about getting an outcome. Neither of those methods will provide you with a goodproduction-ready code that you will have on production. You will be able to deploy on production, I hope,unless you work in source. But what that means is that they will unblock youand you will learn from this so that after five daysyou don't have nothing. Instead, you have something. You have learned a lot of things and you can move forward. And here's the most important part. Most of the developers thinkthat they are a fucking plotter machine,meaning all the lines I'm gonna put on this paperare perfect and I need to know what the lines arein advance, basically. But that's not how creative process works, okay? You're not just creating the final solution right away. Instead, what happens is that when you arein a creative process, I have a sisterwho is a graphic designer, basically,they do a lot of, you know, they try a lot. So this is like an incremental process here, right? Getting closer to the solution. And we kind of understand this because we understandwe can do refactoring later on, right? The part that we do not understand is thatthat's not actually how it works, okay? It's not like you will move forward all the time. Instead, what happens is that the creative processgoes in a different way. What really happens, because that's your solutionif you try to push this, right? Is that while the refactoring of code is very important,you have to do it, you know, that's the only wayto get perfection, before you actually create this code,you have to play around and those graphic designers,they do a shitload of drafts. Basically, if they want to create a picture,draw a picture, right? They will do about 50 different drafts,just taking a look and thinking aboutwhat is the pose of that lady to expresswhat I want to express? And they will throw them away all the time. And they can do it for hours and throw them away. And then when they learn and they understandwhat I want to achieve and how it works,then they're gonna sit down and actually trythis iterative process of improvingthe thing that they draw. And we should do exactly the same thing. But again, a lot of product owners will justhit you in the head and basically tell you,work faster, my slave. You have to do it perfectly,you have no time to fuck around. My answer is, don't tell them that you fuck around. Just fuck around. Learn about what you do, okay? Learn about the different options that you haveto express this code, basically, so that it's readable. So we can work tomorrow on this, right? And it's not just another, you know,the same solution that you did for the last fiveor 10 years, just because you've never learnedanything else. No, you learn by trying things, not by sittingand expecting, you know, the idea to come up to your headand just throw it away, all the time, okay? And you may think that's not exactly howthe professional developers work. For example, there is this guy in the Java world,there's this guy called Josh Long,who did about a few thousand,he's a developer advocate, meaning he's done a lot of,I have no idea how many, but a few thousand,at least, presentations of live coding, okay,on the stage. And when people see how he does live coding,they are like, whoa, I want to be like this someday, right? Because he's so fast and he's coding all the time,you know, talking in the coding all the time,and you basically see him, he writes fasterthan you think about the solution, right? But here's the thing, he did that a few hundred times beforeand he's just repeating himself. And the first time he had to come upwith this kind of a presentation,it took him a week to work on. How do I know about that? Because I do exactly the same thing. It takes a lot of time to train, to remember all of this,so you can talk about it and at the same time do it, right? And you have to understand what's the outcomethat you want to get. That's the only way when you want to actually dothis kind of a live coding exerciseand so that looks really cool, right? And people don't know that that's exactly what happens. This is the guy, there's a lot of TV shows on how to paintand this is one of the best of them. This gentleman actually would paint a picture,talking as he goes on TV, basically, live,and talking all the time about happy accidents. That, you know, if you make a mistake,it's a happy accident because you can use that mistaketo create something new, to open up your mindand basically draw something, right? And it looks beautiful. I love watching this guy basically because of allthe positive emotions he has when he's drawing all those,painting all those pictures. Now here's the funny thing. When he does this, he makes you think that he doesn't knowwhere he's going, that all those mistakes are real. The funny thing is, before every TV session,he actually painted that picture once, at least. So after he was dead, they were selling all the old picturesfor every single season, every single TV show that he didand now you learn that actually all these happy accidents,they were planned. He did that before and he spent a week on this, right? Before he was actually showing this. So basically, he was fucking around for a weekjust to give you a single show, right? That's the senior developer there. And that's exactly what you should do. Okay, that's six p. m. How much time do you have? Over. - Maybe a few minutes. - Maybe a few minutes. Okay, so that was my advice in terms of what you should dobecause, well, as Hemingway said once,the first draft of anything is shit, okay? And when he was actually writing the, what was it? He was writing Firewell to Arms. He wrote the beginning of it 50 timesand threw it out away, right? So do this and don't tell anybodybecause if you're gonna talk with your product ownerand tell him that you're destroying all those branches,they are not going to like it. But if you just delete those branches,if you even have to push this to repository,then it's okay, nobody will know. And the end outcome will be you're gonna get there fasterthan instead of thinking about I need to havethe perfect picture in my headbefore I actually write the codeor trying to use the same patternthat you did the last time with another feature, okay? So fuck around, implement it, delete it,implement it again, get closer, repeat,don't be afraid of wasting time. You're not wasting time, you're learning. You are learning about the different,the area of different options that you have,different solutions that you might haveto choose the best solution that you will get, right? You're not a printer, you're not a plotter. You learn by making mistakes,not by listening to some guy on the stage, right? You have to actually make those mistakes. Is that how your brain changes, okay? And rewriting this implementation,you may think that oh, but this is going to takeso much time because I'm going to rewrite itover and over again. When I make a mistake, I'm gonna delete it straight again,right? No, that's not the case because if you think about it,most of the time developers do not write code. They try to think and find where to write,what to write, and how the hell is it going to behave, right? Just the fact of writing the code fastermakes no sense to us because we don't spend most of the timeactually putting the, you know, pressing the keyson this keyboard, at least not to write the code,actually to understand how to do it correctly, right? So it's completely fine. Yeah. And also that if you delete this code often enough,what will happen is you will learn how to be egoless,meaning you will not be, you know, the victimof your own code that you cannot delete anymore. I saw a company once where what they did,they had a Git repository, like everyone these days,and they had like hundreds and thousands of methodsthat are not used on production anymore. And I asked them why. Why do you have v5 of the API and v4 and v3 and v2 and v1when your mobile app actually moved to the v5half a year ago? Why do you keep all of them there, right? And they couldn't answer. The answer is they couldn't push themselves to delete this. And they have repository which remembers everything, right? But they just say, I wrote this, this is mine. I have to keep it on production, right? It's not been used. It doesn't matter, right? It's my life. No, learn to delete the code. The code is shit anyway. You're gonna learn how to do it better. Delete the code, write it again. Don't worry about this, okay? So how much time do we have? Okay, finish. Just 30 more slides. So here's the thing. Now that we wrote the code,it's ready to go into production, right? Well, not yet, because you see, this is the picture. I know it's a kind of blur, but this is the whole universe,the whole visible universe. This is all of it, because the universe expands. So due to the speed of light and that it expands,we're gonna see less and less of it. So the next generations will not be ableto see as much as we do, okay? So this is the whole visible universe, okay? And your application, at this point,is not in the fucking visible universe. That's a problem. What do I mean by that? Well, we don't know what the app is doingwhen it goes into production at this point,because we have the code, but most of the developers,what they do, they don't provide proper logging. For example, here's the thing. Take a look at this method, which I showed you before. It looks quite okay. We want to send results to reporterwhen we have something to report to, right? If we didn't import anything, why should we send the resultsto another module or microservice? What would be the point? Here's the thing. Think about what happens if it goes on productionand somebody uploads a file and nothing happens, right? And they say, "Oh, I can't see the reports for this," right? Now they will call you, and basically,you are now a customer care for your business, right? And you will say, "Oh, give me the name of the file. "And they'll give you the name of the file,and you're gonna search through logs to see what happened. And you're gonna see nothing,because this code has a branch in it. We can do something or do nothing,but you will never know that you did nothing for a reason. You don't know if the app actually crashedor maybe some other thing has happened, you know,cosmic rays, whatever, yeah? So that's the typical problem. Well, not too many developers actually understandhow to do the logging properly. And the answer to this is very simple. What you have to do is you have to put logson every single branch, logical branch of your code. That doesn't mean put the log on every second line. I've seen solutions like this, and they are uglyand you cannot work with the code anymorebecause it's logged everywhere, right? But instead, what you have to do is whenever you havea logical branch, the code can go this directionor that direction, and doing nothing is oneof those directions. Then you have to at least log when you don't do it, right? So that we can actually, here we expect what will happenin production from time to time,what kind of questions we're gonna get,and how am I going to answer those questionswhen I get them from the customer, right? So, do this, but not only that. The thing is to provide the whole observability,meaning to be able to see what's going on in the productionwithout the debugger. And that requires both logging on every single logical branchand then not logging when there is no branch. If you're just following step by step,the process is linear, right? It makes no sense to put a log therebecause you know what exactly will happen next. You can look at the code. But if it branches, you have to put the log there. But then you have to think about business metrics, okay? What should we show so that we understandhow the application behaves in production? Like for example, I'll give you a few examples. Number of uploads, right? How about distribution of the sizes of these files? We will learn a lot if we understand,are those big files, are those small files? What can we optimize from this? We can put a metric on the number of failures per invoice,right, does it increase? Are those invoices better or worse? Okay, and so number of failures per failure type. What kind of errors are the most common? All these kind of things, right? And you can put them as you write this codewith libraries that actually provide you metrics. And this will make the application observable. And what happens next is beautifulbecause instead of wasting your time,searching through logs and finding nothingand then trying to basically become a Sherlock Holmesand find out what happened,what the hell happened on my application. Every time something wrong happens and somebody calls you,you will have it right in your face. And the best thing, the best way to achieve thisfrom my perspective is something like, let me show you this. I do test driven development,actually behavioral driven development,so I write test first all the time, right? And when I write those tests, if the test fails,I'm writing the test, then I'm writing implementation,changing the test and implementation,as we go. When I have a problem and every developer does the same,I will put a break point there, right? To find out what's going on with that variableor what happens when I call this method, right? Well, stop, because on production,you don't have that debugger yet. And sometimes you can't even put it therebecause it slows you down, the production down. So instead, what should happen is take a look at your logsand see if you can understand when the test is read,basically, you're writing a new testand the test is read fails, but it shouldn't fail,actually have an implementation for it. Now take a look at the logs. Do they tell you exactly what happened? If they don't, they will not tell you what happenedwhen you go to production. If they do, you don't need the debugger anymore, okay? So it's as that simple. But to get there and to have this kind of,this is an example of those logs from real production,to have this business logs which actually tellthe whole story and explain what's going onwith the system step by step on every single branch,you actually have to remove a lot of clutterbecause those logs actually look like thisat the very beginning. All the libraries are trying to lock something, right? And you cannot find shit in those logsbecause there's so much stuff therethat your logs are basically at the very bottomor somewhere in the between. And that's why a lot of Polish developers write this logfor dupa because then we can search for dupaand we know this is our error, right? Or our log. That's why we do it. But basically the proper way to do itis to remove all this clutterby configuring the logging framework. And it's very simple. You have to have some files. I have a solution for this for Java. But basically every single librarywill allow you to configure,turn off all those not interesting logsfrom all those libraries. Leave the ones that are interesting, okay? Or put them at the error level when they are interestingor the warn level and remove those infos. And put those logs that you are interested in,especially your own logs thereso they tell you exactly the storyand you will have something like this,which is actually from the unit test that I was writingand basically giving me all the feedbackI don't have to look at the buggerbecause you most likely do not have a debuggeron the production. Although it's possible,but not too many companies do it, right? And it's after the fact. Okay, one last thing I can recommendis doing MOB code review. And a lot of different companies,code review is something you have to wait for,you have to ask for,basically you have to beg for itand the next day maybe it will happen or not. A simple solution to all of this,if you have such a situationbecause not every company has it,when if you have a daily,like a daily standup meeting, you know, Scrum,then after the daily, at the end of the daily,you can actually say, okay, let's do the reviewsfor all the pull requests that we have,where actually the author of that pull requestexplains how it worksand what's going on with this pull request. And everybody's giving them feedback right away. What happens is that the feedback will be much fasterbecause now you talk, you don't have to write it, right? Much easier to understand large pull request. Maybe you shouldn't have large pull request,but when you have, because some things are big,then it's much easier to understandwhen the author of that code actually explains this. And also it's quite fun when everybody does this. Even my cats actually are sitting hereand watching the pull requests, you know. The pull request is actually on another TV. They are not too smart yet,but I'm teaching them programming. Anyway, so you can do itand you can have those pull requests verifiedin a funny way where one of the benefitsof this kind of a mob code reviewis that we share the way of thinking. So basically you will learn a lotabout how other people think about the code. And if you have something to share with them,they will learn from that as well. So we are bringing all of us up in terms of the skillsetbecause we wanna, we can talk about thisand everybody sees the pull request and talks about it, right? Okay, so now I don't have time to talkabout the bugs in production, which is shame,but you can read it later on. This is the list of all the practices that I've mentionedand one of those that I didn't have time to mention. And you can find my slides on this link. So if you can either to make a photo,that's the only slide you need. And I suppose this will be also available somewherein the, on the site or somewhere else. Thank you very much. (audience applauding)- Well, congratulations, those were great questions. Yes. Thank you. (audience applauding)Please. - Thank you. So I have one more question about what you were sayingabout your developer that was, you know,thinking for a few days and without any resultsin written code. And then a few slides later, you said about senior developerwho is doing exactly the same. I mean, that it is a good practice that we are thinkingfor a long time, not writing code and doing it, you know,like writing codes, deleting it and writing again. So I have a question. Why it's when junior does it, it's badand when the senior does it, it's a good practice. What's the difference? - Sure. At the moment. - So when I was talking about this,that was the case when the senior developersare on a shorter fuse. Basically what they say is that, oh,I'm a senior developer, I'm supposed to write the codes. I'm gonna write the code, no matter whether it's good codeor bad code, I'm gonna use the same patterns that I know. Now, this is what happens when you don't knowand you're afraid, okay? But the difference is with what I showedis we are playing with the code. We are writing the code all the time. We're just not pushing to the repository. There is a difference there because that guywasn't actually pushing in a code to the repository. He was reading the code and thinking for five days. That's it. And he's a friend of mine and he's a very good developerfrom my perspective concerning his age, right? But the problem is that he got stuckbecause he wanted to find out the optimal solutionon the first try. And he was afraid to just play with it. And the difference is that the senior developer will say,I cannot find the perfect solution by thinking about it. That's not how it works. The way it works, I'm gonna play with it. I'm gonna do some programming. And my brain is going to basically switchbecause if you think about it,if you read any books on neurology,what you will find is that we change our brainsduring the sleep after making failures in our lifeduring the daytime. So basically you have to failand you have to feel the pressure from that failure. Not too large because it is too large, you know,you're gonna get depression. But basically you have to feel, ah, I failed,I fucked up, right? And you go to bed. And this is where you try to do something,learn a skill by doing, not thinking about it,but by doing, okay? And you make failures. That's when your brain actually changes your neural networkand creates new paths, basically,or reduces existing things to provide youto do it easier and better. So we do not learn by reading books, unfortunately. We learn by getting the knowledge in and trying it out. Sometimes it's enough to, you know,there are things when all you have to dois think about the book that you've readand then you will learn something. But in our case, in programming,most of the time it's about doing it, you know,for yourself, right? So all I'm saying here, don't try to, you know,wait till the idea comes up and find the perfect solution. Play around with it. Try different methods that you can usejust to, you know, to unblock yourself, okay? I have a list of those methods here. And this is not a finite list anyway. So basically try to do something and learn from doing. Just don't push it to productionbecause then they're gonna kill you. - Thank you very much. It was a great talk. Bravo. (audience applauding)- Thank you. 